
# â€“ Point-to-Point (BCM)

## Goal

Implement and validate a minimal point-to-point program using the Burst
Communication Middleware (BCM), suitable for a live coding evaluation.

This example demonstrates:
- BCM initialization and worker setup (burst size = 2)
- Point-to-point send/recv semantics
- A small correctness hook (msg_id + ACK matching)

## Code Location (this repository)

```

examples/p2p_demo.rs

````

## How to Run (official codebase)

This example was executed inside the official `burst-communication-middleware`
project (RabbitMQ backend enabled):

```bash
RUST_LOG=info cargo run --example p2p_demo --features rabbitmq
````

(Optional release build)

```bash
RUST_LOG=info cargo run --release --example p2p_demo --features rabbitmq
```

## What the Program Does

Two workers participate (`id=0` and `id=1`):

* Worker 0 (sender)

  * sends a payload containing `msg_id`
  * waits for an ACK reply from worker 1
  * checks that the ACK matches the expected `msg_id`

* Worker 1 (receiver)

  * receives the message from worker 0
  * replies with an ACK that includes the received payload

### Message Flow (Round Trip)

1. `worker 0 -> worker 1`: `msg_id=1 hello from worker 0`
2. `worker 1 -> worker 0`: `ack for msg_id=1 hello from worker 0`

## Validation: Execution Proof

The following log snippet was produced during a successful execution:

```text
worker start: id=1
worker start: id=0
worker 0 sending to 1: msg_id=1 hello from worker 0
worker 1 received: StringMessage("msg_id=1 hello from worker 0")
worker 1 replying to 0: ack for msg_id=1 hello from worker 0
worker 0 received reply: StringMessage("ack for msg_id=1 hello from worker 0")
worker 0: ACK matches msg_id=1
worker end: id=0
worker end: id=1
```

This output confirms that:

* both workers were initialized correctly
* point-to-point communication succeeded
* a full request/reply round-trip completed
* the ACK matches the expected message id

## Changes vs. the Official Example

This file was adapted from the official `hello_world_local` example.
Changes were intentionally minimal but meaningful:

* added a `msg_id` in the payload to reason about request/reply association
* modified the reply to include the received payload (`ack for <message>`)
* added an ACK-matching check on the sender side

These changes provide a simple correctness hook that can be discussed during
live coding (ordering, duplication, delivery assumptions).

## Discussion Prompts (for Evaluation)

* What delivery/ordering guarantees does BCM provide across different backends?
* What happens if a worker is delayed or fails to start (flare/group semantics)?
* Where does buffering/backpressure occur if the sender is faster than the receiver?
